import time

def print_board(game_board):
    # фукнция печати(обновления) текущего состояния игрового поля,
    # game_board(переменная), является аргументом - список в списке
    # список в списке - каркас игры
    print("  0   1   2 ")
    # печатаем верхние номера столбцов
    for i, current_row in enumerate(game_board):
        # запускаем последовательный цикл для итерирования (enumerate)
        # элементов в списке game_board
        # i это переменная для хранения индекса элемента
        print(f"{i} {current_row[0]} | {current_row[1]} | {current_row[2]}")
        # тут я использовал метод f-строк, он же метод форматирования и подставления 'i' в '{}'
        # current_row это текущая строка
        # сначала цикл проходит каждую строчку и анализирует состояние введенных данных,
        # после, цикл анализирует 'input', и подставляет по координатам значение выбранное игроком
        # 'f' строка форматирует текущее положение и подставляет значение 'i' введеное 'input'
        # напр. если 'i = 1', то в 'current_row[1] будет истина, и мы форматируем состояние и подставляем новое значение
        if i < 2:
            #  проверка на ограничение игрового поля и отображение разделения
            # если значение 'i' не 2, значит строка не последняя
            print("  ---------")
            # если не последняя, рисуем разделение

def check_winner(game_board, player):
    # функция для проверки победителя (player) в списке списков (game_board)
    # назвал одинаково так как каждая функция имеет свою область видимости, и переменные в ней локальные
    # что не будет приводить к конфликтам
    for i in range(3):
        # цикл 'for', который проходит по значениям 'i' от '0' до '2'
        if all([game_board[i][j] == player for j in range(3)]):  # Проверка по горизонтали
        # дословно:
        # all используем для проверки ВСЕЙ строки на значение 'player = True'
        # если значение элемента равно символу 'player' то будет True, иначе False.
        # [i] это Фиксированный индекс строки, [j] Изменяемый индекс столбца
        # == метод сравнения
        # цикл нужен для итерации
        # если убрать all, то условие будет True, если хотя-бы один элемент будет равен 'player'
            return True
        if all([game_board[j][i] == player for j in range(3)]):  # Проверка по вертикали
        # в данном случае изменение направления проверки происходит путём указывания Сначала
        # индекса столбца [j]
        # и после индекс строки [i]
        # Таким образом при итерации по столбцам [j] мы изменяем индекс строки [i]
        # это и даёт возможность проверять вертикаль
            return True
        # две проверки которые проверяют все ли значения в строке 'i' равны 'player'
    if all([game_board[i][i] == player for i in range(3)]):  # Проверка по диагонали (слева направо)
        return True
    if all([game_board[i][2 - i] == player for i in range(3)]):  # Проверка по диагонали (справа налево)
        return True
    return False
    # Если ни одно из условий выше не было истинным, значит игрок не выиграл ни по горизонтали, ни по вертикали, ни по диагоналям

def is_board_full(game_board):
    # вся ли игровая зона заполнена?
    for row in game_board:
        # итерируем каждую строку в game_board
        for cell in row:
            # перебираем каждую ячейку в строчке
            if cell == " ":
                # равенство на пробел в ячейке
                return False
                # Если хотя бы одна ячейка пустая, сразу возвращаем False
    return True
    # Если все ячейки заполнены, возвращаем True

def restart_game():
    # Перезапуск игры, и вывод таймера в консоль
    print("Игра будет перезапущена через:")
    for i in range(3, 0, -1):
    # цикл перебора в диапазоне от 3 до 1 с шагом в -1
    # range(start, stop, step)
        print(i)
        time.sleep(1)
    print("REPLAY!")
    time.sleep(1)
    # задержка в 1 секунду перед перезапуском
    play_game()

def play_game():
    # каркас игры, инициализация игрового поля, проверки
    game_board = [[" " for _ in range(3)] for _ in range(3)]
    # game_board переменная которая является списком в списке (3 списка)
    # game_board = [[" ", " ", " "],
    #               [" ", " ", " "],
    #               [" ", " ", " "]]
    # создаем 3 по 3 пустых списка для визуализации игрового поля
    players = ["X", "Y"]
    # создание списка игроков имена которых 'x' и 'y'
    current_player = 0
    # переменная со значением 0, для определения текущего игрока
    # игрок с индексом '0' = 'x', значит он ходит первым

    while True:
        # цикл для проведения игры до момента выигрыша или ничьи
        print_board(game_board)
        # запуск функции обновления состояния игрового поля
        player = players[current_player]
        # получение текущего игрока из списка 'players' по индексу 'current_players'
        while True:
            # цикл для работы проверки хода игрока
            row = int(input(f"Игрок {player}, введите номер строки (0, 1, 2): "))  # строка
            col = int(input(f"Игрок {player}, введите номер столбца (0, 1, 2): ")) # столб
            # int условие для ввода целой цифры, input сам ввод с клавиатуры, импользуем метод f-строк
            # для подставление и форматирования
            if 0 <= row < 3 and 0 <= col < 3:
                # проверяем номер строки и столба от 0 до 2
                if game_board[row][col] == " ":
                    # если первая проверка говорит об том, что введеные значения
                    # соответствует возможным в игре координатным вводам
                    # то проверяем, что ячейка пустая и ничего не делаем в данном блоке
                    break
                else:
                    print("Эта клетка уже занята. Попробуйте снова.")
                    # если нет, то верхний принт
            else:
                print("Неверные координаты. Попробуйте снова.")
                # если координаты не те, то верхний принт

        game_board[row][col] = player
        # указываем на игровом поле ячейку с игроком, который сделал ход

        if check_winner(game_board, player):
            print_board(game_board)
            print(f"Игрок {player} победил!")
            time.sleep(1)
            restart_game()
        elif is_board_full(game_board):
            print_board(game_board)
            print("Ничья!")
            time.sleep(1)
            restart_game()
        else:
            current_player = 1 - current_player

if __name__ == "__main__":
    # условие Python для запуска скрипта при открытии
    play_game()
    # указываем с какой функции начинается запуск скрипта